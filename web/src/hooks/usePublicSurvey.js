import { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { publicSurveyApi } from '../utils/publicSurveyApi.js';
import { useNotifications } from '../components/ui/notifications.jsx';

/**
 * Custom hook for managing public survey state and operations
 */
export function usePublicSurvey() {
  const { token } = useParams();
  const navigate = useNavigate();
  const { showError, showWarning } = useNotifications();
  
  const [step, setStep] = useState('loading'); // loading, start, survey, completed, error
  const [campaign, setCampaign] = useState(null);
  const [flow, setFlow] = useState(null);
  const [sessionId, setSessionId] = useState(null);
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [answers, setAnswers] = useState([]);
  const [progress, setProgress] = useState({ percentage: 0, completed: false });
  const [currentAnswer, setCurrentAnswer] = useState('');
  const [finalBrief, setFinalBrief] = useState(null);
  const [error, setError] = useState(null);
  const [submitting, setSubmitting] = useState(false);
  const [surveyTemplate, setSurveyTemplate] = useState(null);

  const bootstrapSurvey = useCallback(async () => {
    try {
      const data = await publicSurveyApi.bootstrapSurvey(token);
      setCampaign(data.campaign);
      setFlow(data.flow);
      setCurrentQuestion(data.firstQuestion);
      
      // Fetch survey template for styling
      try {
        const templateData = await publicSurveyApi.getSurveyTemplate(token);
        console.log('ðŸŽ¨ Frontend received template data:', templateData);
        setSurveyTemplate(templateData);
      } catch (templateError) {
        console.warn('Failed to load survey template, using defaults:', templateError);
        setSurveyTemplate(null);
      }
      
      setStep('start');
    } catch (error) {
      console.error('Failed to bootstrap survey:', error);
      setError(error.message);
      setStep('error');
    }
  }, [token]);

  const startSurvey = async () => {
    try {
      const data = await publicSurveyApi.startSurvey(token);
      setSessionId(data.sessionId);
      setCurrentQuestion(data.question);
      setProgress(data.progress);
      setStep('survey');
    } catch (error) {
      console.error('Failed to start survey:', error);
      setError(error.message);
      setStep('error');
    }
  };

  const submitAnswer = async () => {
    if (!currentAnswer.trim()) {
      showWarning('Please provide an answer before continuing');
      return;
    }
    
    setSubmitting(true);
    
    try {
      const data = await publicSurveyApi.submitAnswer(
        sessionId, 
        currentQuestion.id, 
        currentAnswer
      );
      
      // Store the answer
      setAnswers(prev => [...prev, {
        questionId: currentQuestion.id,
        question: currentQuestion.text,
        answer: currentAnswer.trim()
      }]);
      
      setProgress(data.progress);
      setCurrentAnswer('');
      
      if (data.progress?.completed) {
        // Survey completed - brief is already generated by the API
        setFinalBrief(data.aiBrief || data);
        setStep('email-capture'); // Show email capture before completion
      } else {
        // Continue to next question
        setCurrentQuestion(data.question);
      }
    } catch (error) {
      console.error('Failed to submit answer:', error);
      showError('Failed to submit answer: ' + error.message);
    } finally {
      setSubmitting(false);
    }
  };

  const submitSurvey = async () => {
    try {
      const data = await publicSurveyApi.submitSurvey(sessionId);
      setFinalBrief(data);
      setStep('email-capture'); // Show email capture before completion
    } catch (error) {
      console.error('Failed to submit survey:', error);
      setError('Failed to submit survey: ' + error.message);
      setStep('error');
    }
  };

  const handleEmailSubmit = async (email) => {
    try {
      setSubmitting(true);
      await publicSurveyApi.updateSessionEmail(sessionId, email);
      setStep('completed');
    } catch (error) {
      console.error('Failed to update email:', error);
      showError('Failed to save email: ' + error.message);
      // Still proceed to completion even if email fails
      setStep('completed');
    } finally {
      setSubmitting(false);
    }
  };

  const handleSkipEmail = () => {
    setStep('completed');
  };

  const goBack = async () => {
    if (!sessionId || answers.length === 0) {
      return;
    }
    
    setSubmitting(true);
    
    try {
      // Go back to previous question (we're currently on question N, want to go back to question N-1)
      // If we have 3 answers, we're on question 4, so we want to go back to question 3 (index 2)
      const targetIndex = answers.length - 1;
      const data = await publicSurveyApi.goBackToQuestion(sessionId, targetIndex);
      
      // Update state with the previous question and answer
      setCurrentQuestion(data.question);
      setCurrentAnswer(data.currentAnswer || '');
      
      // Remove the last answer from the answers array
      setAnswers(prev => prev.slice(0, -1));
      
      console.log(`âœ… Went back to question: ${data.question.text}`);
    } catch (error) {
      console.error('Failed to go back:', error);
      showError('Failed to go back to previous question: ' + error.message);
    } finally {
      setSubmitting(false);
    }
  };

  // Bootstrap survey on load
  useEffect(() => {
    if (!token) {
      setError('Invalid survey link');
      setStep('error');
      return;
    }
    
    bootstrapSurvey();
  }, [token, bootstrapSurvey]);

  return {
    // State
    step,
    campaign,
    flow,
    sessionId,
    currentQuestion,
    answers,
    progress,
    currentAnswer,
    finalBrief,
    error,
    submitting,
    surveyTemplate,
    
    // Actions
    setCurrentAnswer,
    startSurvey,
    submitAnswer,
    goBack,
    navigate,
    handleEmailSubmit,
    handleSkipEmail
  };
}
